---
format: gfm
title: "R package basics"
author: "Beth Jump"
date: "2025-08-07"
execute: 
  warning: false
---
  
## Overview
  
"In R, the fundamental unit of shareable code is the package. A package bundles together code, data, documentation, and tests, and is easy to share with others." [R Packages (2e)](https://r-pkgs.org/introduction.html). We typically access packages from the CRAN but we can also make our own packages and host them on GitHub (relatively easy) or the CRAN (takes a lot more testing and validation). 

The book [R Packages (2e)](https://r-pkgs.org/introduction.html) goes through all of the technical details on how to make an R package, so here we'll go over some basics and some things I've learned about making packages. 

### Functions vs sourcing scripts

There are two main ways to ensure code is being processed uniformly in a series of scripts: 

1. functions
2. sourcing scripts

In most cases you can use either one. Functions only return one object so if you need more than one object from a process, you might want to consider a sourced script. A sourced script is also generally easier to troubleshoot because you're explicilty running code whereas in a function you're renaming inputs to do things.

Functions are great for small, discrete tasks like getting the newest file in a folder, reading in a certain type of file, or formatting a chart in a specific way. Sourced scripts are best for long processes that need to be done the same way every time.

Note: If you're accessing data from Azure with a sourced script, consider using a SQL view instead! A view in SQL is a stored query (effectively a sourced script). When you call the view from R, it runs the code and gives you the output as a 2x2 table. 

### Packages vs local functions

Once you've decided you definitely are going to use a function instead of a sourced script, you then need to think about whether or not it makes sense to create an R package to publish your function. Writing, publishing and maintaining an R package is a good amount of work and when you make updates you need to re-test and re-document your work which can take time.

My rule of thumb is to put generalizable, discrete functions (formatting a chart, connecting to Azure, etc) into R packages but to keep large functions used to process specific data sets (ex: my function to clean and format VRBIS) as "local" R functions that are saved as R scripts in projects on GitHub. Part of the reason I don't want to publish my VRBIS function is that the data set often changes and I don't want to deal with updating a published package every time a column is added. 

## Package basics

Before you write your own package, I highly suggest you go through [this exercise](https://r-pkgs.org/whole-game.html) and create a "toy" package. 

#### Naming functions

Each function you write should have on purpose and the name should clearly reflect that purpose without being too long. Your names should also follow the [tidyverse style guide for object names](https://style.tidyverse.org/syntax.html).  

* Good names: fetch_vrbis(), clean_vrbis()
* Less good names: fetchVrbis(), clean.Vrbis()

#### Referencing other packages in your functions

If your function references any functions that aren't included in base R, you need to do a few things:

1. In the actual function, you need to use the `package::function` notation to clearly tell R where to find the referenced function. Ex: `dplyr::filter()` instead of just `filter()`. 
2. You also need to import or suggest any external packages in your `DESCRIPTION` file. It's not always clear whether to import or suggest a [file](https://r-pkgs.org/dependencies-mindset-background.html#sec-dependencies-imports-vs-suggests) but this gives some guidelines. 
3. If there is an external function that you're using a lot in your package and you don't want to have to reference its package every time you use it, you can add that function to the `NAMESPACE` file. If you're using any tidyverse syntax, you will need to do this to use the pipe `%>%`. 


Note that you can write functions that reference other functions in your package. I did this with the [life expectancy functions](https://github.com/San-Mateo-County-Health-Epidemiology/smcepi/blob/main/R/life-expectancy.R). The `life_table()` function only exists to be referenced by the `make_life_table()` function. When you use the `smcepi` package, the `life_table()` function isn't available for use as it doesn't have the `@export` tag. 

### Writing functions

When writing a function for a package, you really want to think about how the code will be used an do your best to make your function as user-friendly as possible. Let's go through an example with a function I wrote to get the newest file in a folder.

Originally, I had a chunk of code that I would copy from script to script:

```
file <- file.info(list.files(path = "",
                             pattern = "*.csv",
                             full.names = T)) %>%
  data.frame() %>%
  rownames_to_column("file") %>%
  mutate(downloaded_date = as.Date(mtime)) %>%
  filter(downloaded_date == most_recent_data) %>%
  pull(file)
```

This generally worked well, but eventually I got sick of copying and re-writing this code every time I needed the newest file in a folder. When I decided to make it a function, I changed two things: I rewrote the function in base R and I added some options for the user to decide how they wanted to select their file. 

#### tidyverse to base R

To rewrite this function in a package, I would need to reference the packages for each function. This is a small function, so adding packages wouldn't be that hard, but if any of the referenced packages changed how their function works, it would then also affect my function. I didn't want to worry about that, so I rewrote this in base R:

```
get_file_path <- function(directory = getwd(), pattern = NULL, sort_method = "created date", sort_type = "newest", include_directories = FALSE) {
  files <- list.files(path = directory,
                      pattern = pattern,
                      full.names = T)
  files <- file.info(files)
  
  files["sort_col"] <- files[[sort_method]]
  rownames(files[order(files$sort_col, decreasing = sort_type),][1,])
}

```

#### adding user options

When I just used the code to select files, I could change how the files were sorted, decide to get full file paths and whether or not to include directories in my results. I wanted to include those options in my function:

`get_file_path <- function(directory = getwd(), pattern = NULL, sort_method = "created date", sort_type = "newest", include_directories = FALSE)`

Then I had to add some checks in my function that these inputs were handled correctly:

```
# ensure a valid sort method was inputted ---------------------
sort_method <- rlang::arg_match(sort_method, c("created date","modified date", "accessed date"))

switch(sort_method,
       `created date` = {sort_method = "ctime"},
       `modified date` = {sort_method = "mtime"},
       `accessed date` = {sort_method = "atime"})
```

### Documentation

Documentation is the most important part of your function. If people don't know how to use your function, they won't use it. R makes it pretty easy to write documentation for a function. Put your cursor in your function, then go up to the top toolbar and select **Code > Insert Roxygen Skeleton**. That will give you the outline to write your documentation.

I don't love the default the roxygen skeleton. It doesn't have some inputs included like `description`. I typically use an outline that I took partially from the `tidyr::separate` documentation on github. 

* helpful tip: if you want to include example code that you don't want to run, you can enclose it in brackets precented by : `\dontrun`. Ex: 

```
#' \dontrun{
#'
#' # get the file that was most recently accessed in a directory
#' get_file_path(sort_method = "accessed date", sort_type = "newest")
#'
#' # get the first file that was created in a different directory
#' get_file_path(directory = "data", sort_type = "newest")
#'
#' # get the most recently modified parquet file in a directory
#' get_file_path(directory = "data", pattern = "*.parquet",
#'               sort_method = "modified date", sort_type = "newest")
#'
#'}
```

### Testing your functions

When building a function, you should also include at least one test per function. The [`testthat`](https://testthat.r-lib.org/reference/index.html) package has 