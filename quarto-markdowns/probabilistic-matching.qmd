---
title: "probabilistic matching"
format: gfm
author: "Beth Jump"
date: "2022-08-11"
execute:
  warning: false
  eval: false
---

## Overview

Probabilistic matching is a method of matching that lets you match values that aren't exactly the same. This method is particularly helpful when matching names across data sets. 

There are two packages I like to use when doing probabilistic matching:

- `RecordLinkage`
- `FastLink`

Each package has its pros and cons, so I typically use both when matching. My process for doing probabilistic matching is:

1. Clean data and do an exact match
2. Run `RecordLinkage::compare.linkage()` to get probabilistic matches
3. Run `fastLink::fastLink()` to get probabilistic matches
4. Compare matches from `RecordLinkage` and `fastLink`
5. Re-run records that only matched with `fastLink` back through `RecordLinkage`
6. Manually review probabilistic matches and combine with exact matches

## Using RecordLinkage

### Set up

`compare.linkage()` is a powerful yet particular function. Before using the it, you need to prepare your data in a very specific way:

* rename the variables in each of your data sets so they have the exact same names, are in the same order and are coded the same way: both use M/F/U for sex, all characters are lowercase, all years are 4 digits, etc
* split dates into their composite parts. Instead of `dob` you should have `dob_y`, `dob_m` and `dob_d`
* remove any fields that you don't want to compare 
* if you have a record id, you should put this in the first position in both data sets. `compare.linkage()` compares variables by position so data1.col1 is compared with data2.col1, data1.col2 with data2.col2, etc. 

These two data sets could be run through `compare.linkage()` successfully:

**data1**

| record_id | first_name | last_name | dob_y | dob_m | dob_d | sex | 
| --------- | ---------- | --------- | ----- | ----- | ----- | ----|
| 1A        | Leia       | Morgana   | 1960  | 7     | 27    | F   |  

**data2**

| record_id | first_name | last_name | dob_y | dob_m | dob_d | sex | 
| --------- | ---------- | --------- | ----- | ----- | ----- | ----|
| 1000      | Leya       | Morgan    | 1962  | 7     | 27    | F   |  


### Using `compare.linkage()`

`compare.linkage()` has many arguments. I typically use these:

* `dataset1`: this is where you put the first data set you want to match
* `dataset2`: this is where you put the second data set you want to match
* `blockfld`: this is where you pass a list (`list()`) of variables you want to match. These variables should be listed in the same order as they appear in your data
* `exclude`: this is a list of numbers that indicate the position of variables to exclude. If you pass a `1`, it will exclude the first variable in both data sets from the match
* `strcmp`: I set this to `T` when I'm matching string variables. 

Here's how we'd use this for the data shown above:


```{r}
rl_matches <- compare.linkage(dataset1 = data1, 
                              dataset2 = data2,
                              blockfld = list("first_name", "last_name", "dob_y", "dob_m", "dob_d"),
                              exclude = 1,
                              strcmp = T)
rl_pairs <- rl_matches$pairs
```

### Reviewing matches

The `rl_pairs` table will have a column for each of the variables passed to the `blockfld` argument and will have columns called `id1` and `id2` which correspond to the row numbers in datasets 1 and 2 where the matches can be found.

This is how the matches might look if we ran the data from above through `compare.linkage()`:

| id1 | id2 | first_name | last_name | dob_y | dob_m | dob_d | sex | 
| ----|---- | ---------- | --------- | ----- | ----- | ----- | ----|
| 1   | 960 | 0.8        | 0.9       | 0.67  | 1     | 1     | 1   |  

By looking at `id1` and `id2`, we can see that this is the match of row 1 of `dataset1` and row 960 of `dataset2`. 

For each of the variables passed through `blockfld`, we get a coefficient between 0 and 1. 1 is a perfect match and 0 is no match (though the method for figuring that out is not clear to me). 

To parse through all the potential matches, I add some additional logic to flag which matches I want to definitely keep. 

```{r}
rl_all_matches <- prob_match_rl_pairs %>%
 #filter(first_name >= 0.5 & last_name >= 0.6 & # sex == 1 &
#          dob_y >= 0.6) %>% #& dob_m >= 0.6 & dob_d >= 0.6) %>%
  left_join(hmis_dems_unmatch, by = c("id1" = "row_number")) %>%
  left_join(death_dems_unmatch, by = c("id2" = "row_number")) %>%
  rowwise() %>% 
  mutate(all_name = sum(first_name.x, last_name.x),
         dob_y.x = case_when(dob_y.y == dob_y ~ 1, TRUE ~ dob_y.x),
         dob_m.x = case_when(dob_m.y == dob_m ~ 1, TRUE ~ dob_m.x),
         dob_d.x = case_when(dob_d.y == dob_d ~ 1, TRUE ~ dob_d.x),
         match = case_when(first_name.x == 1 & last_name.x == 1 & dob_y.x == 1 & dob_m.x == 1 & dob_d.x == 1 ~ "exact",
                           first_name.x == 1 & last_name.x > 0.5 & 
                             dob_y.x == 1 & dob_m.x == 1 & dob_d.x == 1 ~ "fname + dob",
                           first_name.x >= 0.75 & last_name.x == 1 & dob_y.x == 1 & dob_m.x == 1 & dob_d.x == 1 ~ "lname + dob",
                           first_name.x == 1 & last_name.x == 1 & abs(as.numeric(dob_y) - as.numeric(dob_y.y)) < 10 & 
                             ((dob_y.x == 1 & dob_m.x == 1) | (dob_y.x == 1 & dob_d.x == 1) | (dob_m.x == 1 & dob_d.x == 1)) ~ "name + 2 dob elements",
                           first_name.x > 0.6 & last_name.x > 0.615 & all_name > 1.8 & dob_y.x == 1 & dob_m.x == 1 & dob_d.x == 1 ~ "sim name + same dob",
                           first_name.x > 0.5 & last_name.x > 0.5 & all_name > 1.8 & dob_y.x == 1 ~ "sim name + same year",
                           first_name.x > 0.88 & last_name.x > 0.9 & abs(as.numeric(dob_y) - as.numeric(dob_y.y)) < 10 & 
                             ((dob_y.x == 1 & dob_m.x == 1) |
                                (dob_y.y == dob_y & dob_m.y == dob_m) |
                                (dob_y.x == 1 & dob_d.x == 1) |
                                (dob_y.y == dob_y & dob_d.y == dob_d) |
                                (dob_m.x == 1 & dob_d.x == 1) |
                                (dob_m.y == dob_m & dob_d.y == dob_d)) ~ "sim name + 2 dob elements",
                           TRUE ~ "probably no match"))

rl_prob_matches <- rl_all_matches %>%
  filter(!match %in% c("probably no match", "sim name + same year")) #, "sim name + 2 dob elements"))
```


## Using RecordLinkage

### Set up


### Using `compare.linkage()`

### Reviewing matches

